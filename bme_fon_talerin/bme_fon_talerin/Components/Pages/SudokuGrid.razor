@page "/sudokuGrid"
@using System.Text.Json
@using bme_fon_talerin.Data
@using bme_fon_talerin.Data.Models
@using bme_fon_talerin.Models
@using Microsoft.EntityFrameworkCore
@attribute [StreamRendering]

@inject TalerinContext Context
@inject IJSRuntime JSRuntime

@rendermode InteractiveServer

<style>
    .sudokugrid {
        aspect-ratio: 1 / 1;
        height: min(75vh, 65vw);
        width: min(75vh, 65vw);
        display: grid;
        grid-template-columns: @GridLayout;
        background-color: black;
        border: solid black 5px;
        cursor: pointer;
        pointer-events: none;
    }
    .cell {
        aspect-ratio: 1 / 1;
        width: 100%;
        height: 100%;
        background-color: #f1f1f1;
        padding: 5px;
        border-color: black;
        border-width: 1px;
        border-style: solid;
        pointer-events: auto;
    }
    .cell:focus {
        outline: none;
    }
    .cell.borderright {
        border-right-width: 3px;
        padding-right: 3px;
    }
    .cell.borderleft {
        border-left-width: 3px;
        padding-left: 3px;
    }
    .cell.bordertop {
        border-top-width: 3px;
        padding-top: 3px;
    }
    .cell.borderbottom {
        border-bottom-width: 3px;
        padding-bottom: 3px;
    }
    .cellvalue {
        width: inherit;
        height: inherit;
        z-index: 3;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        font-size: 3rem;
    }
    .cellpencil {
        width: inherit;
        height: inherit;
        z-index: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        top: -100%;
    }
    .cellhighlight {
        width: -webkit-fill-available;
        height: -webkit-fill-available;
        z-index: 5;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        top: -200%;
        background-color: transparent;
        margin: -5px;
        border-style: inset;
        border-color: deepskyblue;
        border-width: 10px;
        opacity: 30%;
    }

    .cellpencildata {
        max-width: 5ch;
        font-size: 1rem;
        overflow-wrap: break-word;
        letter-spacing: 0.2rem;
        line-height: normal;
        text-align: center;
    }
</style>

<script>
    let position = {x: -1, y: -1};

    function select(highlighter)
    {
        var highlight = document.getElementById(highlighter)
        highlight.hidden = !highlight.hidden;

        var segment = highlighter.split("-");
        position.x = segment[1];
        position.y = segment[2];
    }
    function deselect(highlighter)
    {
        var highlight = document.getElementById(highlighter)
        highlight.hidden = true;
    }
    function cellFocus(highlighter)
    {
        var highlight = document.getElementById(highlighter)
        highlight.focus();
    }

    const keys = {
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      w: 87,
      a: 65,
      s: 83,
      d: 68,
      digit1: 49,
      numpad1: 97,
      digit2: 50,
      numpad2: 98,
      digit3: 51,
      numpad3: 99,
      digit4: 52,
      numpad4: 100,
      digit5: 53,
      numpad5: 101,
      digit6: 54,
      numpad6: 102,
      digit7: 55,
      numpad7: 103,
      digit8: 56,
      numpad8: 104,
      digit9: 57,
      numpad9: 105,
      back: 8,
      delete: 46
    };

    function handleKey(e)
    {
        console.log(e.currentTarget.dotNetRef);
        let highlight = "";
        switch (e.keyCode) {
        case keys.left:
        case keys.a:
            position.y = (position.y + @SudokuData.Size - 1) % @SudokuData.Size;
            highlight = "cell-" + position.x + "-" + position.y + "";
            cellFocus(highlight);
            break;
        case keys.up:
        case keys.w:
            position.x = (position.x + @SudokuData.Size - 1) % @SudokuData.Size;
            highlight = "cell-" + position.x + "-" + position.y + "";
            cellFocus(highlight);
            break;
        case keys.right:
        case keys.d:
            position.y = (position.y + @SudokuData.Size + 1) % @SudokuData.Size;
            highlight = "cell-" + position.x + "-" + position.y + "";
            cellFocus(highlight);
            break;
        case keys.down:
        case keys.s:
            position.x = (position.x + @SudokuData.Size + 1) % @SudokuData.Size;
            highlight = "cell-" + position.x + "-" + position.y + "";
            cellFocus(highlight);
            break;
        case keys.digit1:
        case keys.numpad1:
            UpdateValue(1);
            break;
        case keys.digit2:
        case keys.numpad2:
            UpdateValue(2);
            break;
        case keys.digit3:
        case keys.numpad3:
            UpdateValue(3);
            break;
        case keys.digit4:
        case keys.numpad4:
            UpdateValue(4);
            break;
        case keys.digit5:
        case keys.numpad5:
            UpdateValue(5);
            break;
        case keys.digit6:
        case keys.numpad6:
            UpdateValue(6);
            break;
        case keys.digit7:
        case keys.numpad7:
            UpdateValue(7);
            break;
        case keys.digit8:
        case keys.numpad8:
            UpdateValue(8);
            break;
        case keys.digit9:
        case keys.numpad9:
            UpdateValue(9);
            break;
        case keys.back:
        case keys.delete:
            ClearCell();
            break;
        }
    }
    
    function addKeyboardListenerEvent(dotNetReference) {
        window.dotNetRef = dotNetReference;
        window.addEventListener('keydown', handleKey)
    }

    function UpdateValue(value)
    {
        window.dotNetRef.invokeMethodAsync('ValueChanged', Number(position.x), Number(position.y), Number(value));
    }

    function ClearCell()
    {
        window.dotNetRef.invokeMethodAsync('ClearCell', Number(position.x), Number(position.y));
    }
    console.log("Javascript Ran");
</script>

<PageTitle>SudokuGrid</PageTitle>

<p>Sudoku Grid</p>

<div class="sudokugrid" --grid-rows="@SudokuData.Size" --grid-columns="@SudokuData.Size">
    @for (var row = 0; row < SudokuData.Size; row++)
    {
        @for (var column = 0; column < SudokuData.Size; column++)
        {
            <SudokuCell Parent="this"
                        Row="row"
                        Column="column"
                        Value="GivenCells[row][column]"
                        GridType="@GridType"
                        Rand="@Rand"></SudokuCell>
        }
    }
</div>

<div>
    <SudokuControls Parent="this"></SudokuControls>
</div>

@code {

    private Sudoku SudokuData { get; set; }
    private string GridType { get; set; }

    private int?[][] GivenCells { get; set; }
    public SudokuCell[][] Cells { get; set; }
    public SudokuControls Controls { get; set; }

    private string GridLayout { get; set; } = "";

    private Random Rand { get; set; }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        var dotNetReference = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("addKeyboardListenerEvent", dotNetReference);
    }

    protected override async Task OnInitializedAsync()
    {
        Rand = new Random();
        SudokuData = Context.Sudokus.First();
        var rule = Context.SudokuRules.Where(x => x.SudokuId == SudokuData.Id && x.Rule.Name == "Box").Include(x => x.Rule).Single();
        GridType = rule.Rule.Name;

        GivenCells = JsonSerializer.Deserialize<SudokuGridCells>(SudokuData.GivenCells).Cells;

        Cells = new SudokuCell[SudokuData.Size][];
        for (var size = 0; size < SudokuData.Size; size++)
        {
            GridLayout += " auto";
            Cells[size] = new SudokuCell[SudokuData.Size];
        }
    }

    [JSInvokable]
    public async void ValueChanged(int x, int y, int value)
    {
        var state = Controls.State;
        if (state == "value")
        {
            Cells[x][y].UpdateValue(value);
        }
        else if (state == "pencilMark")
        {
            Cells[x][y].UpdatePencilMarks(value);
        }
    }

    [JSInvokable]
    public async void ClearCell(int x, int y)
    {
       Cells[x][y].ClearCell();
    }
}